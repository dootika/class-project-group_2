<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Zehaan Naik">

<title>Anime Alchemy</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="ProjectReport_files/libs/clipboard/clipboard.min.js"></script>
<script src="ProjectReport_files/libs/quarto-html/quarto.js"></script>
<script src="ProjectReport_files/libs/quarto-html/popper.min.js"></script>
<script src="ProjectReport_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="ProjectReport_files/libs/quarto-html/anchor.min.js"></script>
<link href="ProjectReport_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="ProjectReport_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="ProjectReport_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="ProjectReport_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="ProjectReport_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Anime Alchemy</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Zehaan Naik </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>The term “Anime” refers to all animated motion pictures that are produced in Japan. This is a booming industry with an ever-increasing audience and rising popularity. Naturally, this becomes an excellent opportunity for studios to make massive profits and an exciting field for one to study.</p>
<p>Anime Alchemy is a data visualization app that helps you analyze and compare the performance of various Anime series with several variables that define them. This application aims to help producers develop the best broadcasting and advertising model to ensure the success of their new program.</p>
<p>However, before diving into the application, we should first understand and explore the data set.</p>
</section>
<section id="data" class="level2">
<h2 class="anchored" data-anchor-id="data">Data</h2>
<p>The data set we will be using for our analysis comprises the top 1000 Anime shows on the website<a href="https://myanimelist.net/topanime.php">MyAnimeList</a>. We shall talk more about scrapping the data set in a later section.</p>
<p>As mentioned, the data set comprises 1000 observations described using 38 variables. We can divide these variables broadly into two categories: numerical and categorical.</p>
<section id="numerical-variables" class="level5">
<h5 class="anchored" data-anchor-id="numerical-variables">Numerical Variables:</h5>
<p>These are the columns of our data set that have numerical values associated with them—for example, rating, number of likes, active viewers, etc.</p>
<p>These variables help us mathematically analyze the performance of several substrata of data points. Here is a brief description of all the columns that we have used in our analysis:</p>
<ol type="1">
<li><u><strong>Rating (Score):</strong></u></li>
</ol>
<p>This is the average rating given to the show by everyone who rated the show. An important thing to note is that a high rating need not imply a more extensive audience size or popularity. The reason is that ten people can rate one show to be 9/10. However, another show might be rated by 100 people with a rating of 8.5. As a producer, you might favor the latter over the former.</p>
<ol start="2" type="1">
<li><u><strong>Number of Votes:</strong></u></li>
</ol>
<p>This is the number of votes the show received on the website in a poll where users were asked about their top 10 favorite anime shows.</p>
<ol start="3" type="1">
<li><u><strong>Number of Favourites:</strong></u></li>
</ol>
<p>This is the number of users who have marked a particular show as one of their favorites on the website.</p>
<ol start="4" type="1">
<li><u><strong>Number of Active Viewers:</strong></u></li>
</ol>
<p>The number of people have watched over ten episodes of one particular show. Note that it is essential to distinguish between a viewer who has simply watched a single episode of a show and one who continuously watches the show. As a producer, we are primarily interested in the latter category predominantly.</p>
<ol start="5" type="1">
<li><u><strong>Number of Episodes:</strong></u></li>
</ol>
<p>The number of episodes per season for a particular show.</p>
<ol start="6" type="1">
<li><u><strong>Duration Per Episode:</strong></u></li>
</ol>
<p>The average duration per episode for the show.</p>
<p>(NOTE: Variables 5 and 6 are often used as grouping variables to analyze what range of episode number and duration sits well with a particular target audience.)</p>
<ol start="7" type="1">
<li><u><strong>Color Composition:</strong></u></li>
</ol>
<p>We analyzed the posters for all the shows and studied the color composition of all the posters regarding their percentage RGB composition. We stored these values in separate columns to use as both grouping parameters and analysis parameters to explore various questions of possible co-relations between poster color composition and other parameters.</p>
</section>
<section id="categorical-variables" class="level5">
<h5 class="anchored" data-anchor-id="categorical-variables">Categorical Variables:</h5>
<p>These columns of our data set have non-numerical values such as names, seasons, origins, etc. We've used these values as grouping parameters to subset our data and observe various trends that emerge in such observations. Here is a brief description of all the groups that we have used:</p>
<ol type="1">
<li><u><strong>Source:</strong></u></li>
</ol>
<p>Every anime has a source from which it is inspired. For example, we have "One Piece" inspired by Manga. Similarly, other sources may include games and comics; some might be original works.</p>
<ol start="2" type="1">
<li><u><strong>Genre:</strong></u></li>
</ol>
<p>The genre of the show. It has categories like action, adventure, drama and comedy.</p>
<ol start="3" type="1">
<li><u><strong>Season of Premier:</strong></u></li>
</ol>
<p>What season of the year was the anime premiered in? For example, it is a common understanding that shows meant for children perform better when released in summer. This is because many children are eager to consume TV content during their vacations.&nbsp;</p>
<ol start="4" type="1">
<li><u><strong>Day of Telecast:</strong></u></li>
</ol>
<p>The day of the week on which the show is telecasted.</p>
<ol start="5" type="1">
<li><u><strong>Target Demographic:</strong></u></li>
</ol>
<p>The age section of the audience that the show is aimed at. For example, an anime series like "Shin-chan" is targeted toward a younger audience than compared to a series like "Full Metal Alchemist."</p>
<ol start="6" type="1">
<li><u><strong>Censorboard Rating:</strong></u></li>
</ol>
<p>The age group that the censor board of Japan deems the show safe for.</p>
</section>
</section>
<section id="obtaining-data" class="level2">
<h2 class="anchored" data-anchor-id="obtaining-data">Obtaining Data</h2>
</section>
<section id="biases-in-our-data" class="level2">
<h2 class="anchored" data-anchor-id="biases-in-our-data">Biases in Our Data</h2>
<div style="page-break-after: always;"></div>
</section>
<section id="key-questions" class="level2">
<h2 class="anchored" data-anchor-id="key-questions">Key Questions</h2>
</section>
<section id="key-visualizations" class="level2">
<h2 class="anchored" data-anchor-id="key-visualizations">Key Visualizations</h2>
<div style="page-break-after: always;"></div>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>